<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>フリッピーバード - 指数スコア版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #4fc3f7, #b3e5fc);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial Black', Arial, sans-serif;
        }
        canvas {
            border: 4px solid #0277bd;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 360;
        canvas.height = 540;

        const GRAVITY = 0.3;
        const FLAP_STRENGTH = -5.5;
        const SPAWN_RATE = 110;
        const PIPE_WIDTH = 60;
        const INITIAL_PIPE_GAP = 140;
        const MIN_PIPE_GAP = 90;
        const GAP_REDUCTION_RATE = 2;

        let bird;
        let pipes = [];
        let clouds = [];
        let score = 0; // 内部的な指数n
        let gameState = 'start';
        let frameCount = 0;

        // --- アニメーション用変数 ---
        let lastScore = 0; 
        let animStartTime = 0;
        const ANIM_DURATION = 500; // 0.5秒

        // --- ユーティリティ: カンマ区切りフォーマット ---
        function formatScore(n) {
            // 指数が1024以上になると 2^1024 ≒ 1.79e308 を超える
            if (n >= 1024) return "infinity";
            
            // BigIntで 2^n を計算
            const bigVal = BigUint64Array; // 未使用だがBigIntの存在確認
            const val = BigInt(2) ** BigInt(n);
            
            // カンマ区切り文字列に変換
            return val.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        // 現在のアニメーション中の値を計算
        function getAnimatedScore() {
            if (gameState === 'start') return "1";
            
            const now = performance.now();
            const elapsed = now - animStartTime;
            const progress = Math.min(elapsed / ANIM_DURATION, 1);

            // 指数が1024を超える場合は即座にinfinity判定へ
            if (score >= 1024) return "infinity";

            // 0.5秒のアニメーション中は、前回のスコアから今回のスコアまで線形補完した値を表示
            // (巨大な数値のためBigIntで補完計算)
            const startVal = BigInt(2) ** BigInt(lastScore);
            const endVal = BigInt(2) ** BigInt(score);
            const diff = endVal - startVal;
            const currentVal = startVal + (diff * BigInt(Math.floor(progress * 100)) / 100n);
            
            return currentVal.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        class Bird {
            constructor() {
                this.x = canvas.width / 3;
                this.y = canvas.height / 2;
                this.velocity = 0;
                this.size = 18;
                this.rotation = 0;
            }
            update() {
                this.velocity += GRAVITY;
                this.y += this.velocity;
                this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, this.velocity * 0.1));
                if (this.y + this.size > canvas.height - 20 || this.y - this.size < 0) gameState = 'gameover';
            }
            flap() {
                this.velocity = FLAP_STRENGTH;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = '#fdd835';
                ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#f57f17'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.size/2, -this.size/4, this.size/3, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(this.size/2 + 2, -this.size/4, this.size/6, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#ff5722'; ctx.beginPath(); ctx.moveTo(this.size-2, 0); ctx.lineTo(this.size+12, 4); ctx.lineTo(this.size-2, 8); ctx.fill(); ctx.stroke();
                ctx.restore();
            }
        }

        class Pipe {
            constructor() {
                this.x = canvas.width;
                this.passed = false;
                const gap = Math.max(MIN_PIPE_GAP, INITIAL_PIPE_GAP - Math.floor(score / 5) * GAP_REDUCTION_RATE);
                this.topHeight = Math.random() * (canvas.height - 100 - gap - 60) + 60;
                this.bottomY = this.topHeight + gap;
                this.gap = gap;
            }
            update() {
                this.x -= 2.5;
                if (!this.passed && this.x + PIPE_WIDTH < bird.x - bird.size) {
                    lastScore = score;
                    score++;
                    animStartTime = performance.now(); // アニメーション開始
                    this.passed = true;
                }
                if (bird.x + bird.size - 2 > this.x && bird.x - bird.size + 2 < this.x + PIPE_WIDTH) {
                    if (bird.y - bird.size + 2 < this.topHeight || bird.y + bird.size - 2 > this.bottomY) gameState = 'gameover';
                }
            }
            draw() {
                ctx.fillStyle = '#43a047'; ctx.strokeStyle = '#2e7d32'; ctx.lineWidth = 3;
                ctx.fillRect(this.x + 4, 0, PIPE_WIDTH - 8, this.topHeight - 24);
                ctx.strokeRect(this.x + 4, 0, PIPE_WIDTH - 8, this.topHeight - 24);
                ctx.fillRect(this.x, this.topHeight - 24, PIPE_WIDTH, 24);
                ctx.strokeRect(this.x, this.topHeight - 24, PIPE_WIDTH, 24);
                ctx.fillRect(this.x, this.bottomY, PIPE_WIDTH, 24);
                ctx.strokeRect(this.x, this.bottomY, PIPE_WIDTH, 24);
                ctx.fillRect(this.x + 4, this.bottomY + 24, PIPE_WIDTH - 8, canvas.height - this.bottomY - 24);
                ctx.strokeRect(this.x + 4, this.bottomY + 24, PIPE_WIDTH - 8, canvas.height - this.bottomY - 24);
            }
        }

        class Cloud {
            constructor(startX) {
                this.x = startX || Math.random() * canvas.width;
                this.y = Math.random() * (canvas.height / 2);
                this.speed = Math.random() * 0.5 + 0.2;
                this.scale = Math.random() * 0.6 + 0.4;
            }
            update() { this.x -= this.speed; if (this.x < -100) this.x = canvas.width + 100; }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.scale, this.scale);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2); ctx.arc(30, -10, 35, 0, Math.PI * 2);
                ctx.arc(60, 0, 30, 0, Math.PI * 2); ctx.arc(30, 15, 30, 0, Math.PI * 2);
                ctx.fill(); ctx.restore();
            }
        }

        function initGame() {
            bird = new Bird(); pipes = []; score = 0; lastScore = 0; frameCount = 0;
            animStartTime = performance.now();
            if (clouds.length === 0) for (let i = 0; i < 5; i++) clouds.push(new Cloud(Math.random() * canvas.width));
            gameState = 'start';
        }

        function drawScore() {
            const displayValue = getAnimatedScore();
            ctx.fillStyle = '#fff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
            
            // スコアが長くなるのでフォントサイズを自動調整
            let fontSize = displayValue.length > 20 ? 15 : (displayValue.length > 10 ? 25 : 40);
            ctx.font = `${fontSize}px "Arial Black"`;
            ctx.textAlign = 'center';
            
            // 長すぎる場合は折り返しや省略が必要だが、ここでは画面内に収まるよう調整
            ctx.fillText(displayValue, canvas.width / 2, 80);
            ctx.strokeText(displayValue, canvas.width / 2, 80);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            clouds.forEach(c => { c.update(); c.draw(); });

            if (gameState === 'playing') {
                if (frameCount % SPAWN_RATE === 0) pipes.push(new Pipe());
                pipes = pipes.filter(p => p.x + PIPE_WIDTH > 0);
                pipes.forEach(p => { p.update(); p.draw(); });
                bird.update();
                frameCount++;
            } else if (gameState === 'gameover') {
                pipes.forEach(p => p.draw());
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff'; ctx.font = '30px "Arial Black"'; ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                ctx.font = '15px Arial'; ctx.fillText('Tap to Restart', canvas.width / 2, canvas.height / 2 + 40);
            } else {
                ctx.fillStyle = '#fff'; ctx.font = '20px Arial'; ctx.fillText('Tap to Start', canvas.width / 2, canvas.height / 2);
            }

            bird.draw();
            drawScore();
            requestAnimationFrame(gameLoop);
        }

        function handleInput(e) {
            if (e.type === 'keydown' && e.key !== ' ' && e.key !== 'ArrowUp') return;
            if (gameState === 'start') gameState = 'playing';
            if (gameState === 'playing') bird.flap();
            if (gameState === 'gameover') initGame();
        }

        document.addEventListener('keydown', handleInput);
        canvas.addEventListener('mousedown', handleInput);
        initGame();
        gameLoop();
    </script>
</body>
</html>
